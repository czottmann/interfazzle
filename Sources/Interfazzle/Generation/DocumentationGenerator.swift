import Foundation

/// Generates Markdown documentation from Swift symbol graph files.
///
/// This class is responsible for processing Swift symbol graphs and converting them
/// into human-readable Markdown documentation. It handles symbol filtering, hierarchy
/// organization, and proper formatting of the output documentation.
public class DocumentationGenerator {
  // MARK: - Properties

  /// The directory containing symbol graph files to process.
  ///
  /// This directory should contain .symbols.json files generated by the Swift compiler.
  private let symbolGraphsDir: URL

  /// The directory where generated Markdown documentation will be written.
  ///
  /// Each module will generate a separate .md file in this directory.
  private let outputDir: URL

  /// Mapping of target names to their file system paths.
  ///
  /// This is used to locate README.md files within each target's directory
  /// and include them in the generated documentation.
  private let targetPaths: [String: String] // target name -> path

  /// Whether to include re-exported symbols in the documentation.
  ///
  /// When false, symbols from external modules are filtered out to focus
  /// on the package's own API. When true, all symbols are included.
  private let includeReexported: Bool

  /// Helper for sorting symbols.
  private let sorter = SymbolSorter()

  /// Helper for formatting declarations.
  private let declarationFormatter = DeclarationFormatter()

  /// Helper for formatting markdown.
  private let markdownFormatter = MarkdownFormatter()

  /// Shared JSON decoder for efficient symbol graph parsing.
  private let jsonDecoder = JSONDecoder()

  // MARK: - Lifecycle

  /// Initializes a new DocumentationGenerator instance.
  ///
  /// - Parameters:
  ///   - symbolGraphsDir: The directory containing symbol graph files.
  ///   - outputDir: The directory where documentation will be written.
  ///   - targetPaths: Mapping of target names to their source directory paths.
  ///   - includeReexported: Whether to include re-exported symbols from external modules.
  public init(symbolGraphsDir: URL, outputDir: URL, targetPaths: [String: String], includeReexported: Bool = false) {
    self.symbolGraphsDir = symbolGraphsDir
    self.outputDir = outputDir
    self.targetPaths = targetPaths
    self.includeReexported = includeReexported
  }

  // MARK: - Functions

  /// Generates documentation for all modules in the symbol graphs directory.
  ///
  /// This is the main entry point for documentation generation. It scans the symbol
  /// graphs directory for module files and processes each one to create Markdown
  /// documentation. Modules can be filtered using the includeOnly parameter.
  ///
  /// - Parameter includeOnly: Optional set of module names to process. If nil, all public
  ///   product modules will be processed. This allows filtering to specific modules.
  /// - Throws: Errors if the symbol graphs directory cannot be read or processing fails.
  public func generate(includeOnly: Set<String>? = nil) throws {
    let fm = FileManager.default

    guard let files = try? fm.contentsOfDirectory(atPath: symbolGraphsDir.path) else {
      print("Error: Cannot read symbol graphs directory")
      return
    }

    /// Process only main module files (not @Module.symbols.json)
    let mainFiles = files.filter { $0.hasSuffix(".symbols.json") && !$0.contains("@") }

    for file in mainFiles {
      let moduleName = file.replacingOccurrences(of: ".symbols.json", with: "")

      /// Filter to included modules if specified
      if let includeOnly, !includeOnly.contains(moduleName) {
        continue
      }

      try processModule(moduleName: moduleName, fileName: file)
    }
  }

  // MARK: - Private Functions

  /// Returns the lowercase type label for a symbol.
  ///
  /// This method maps symbol kind identifiers to their lowercase type names
  /// for use in documentation tables and headings.
  ///
  /// - Parameter symbol: The symbol to get the type label for.
  /// - Returns: Lowercase type label (e.g., "class", "struct", "enum").
  private func getTypeLabel(for symbol: SymbolGraph.Symbol) -> String {
    let kindIdentifier = symbol.kind.identifier

    return switch kindIdentifier {
      case "swift.class":
        "class"
      case "swift.struct":
        "struct"
      case "swift.enum":
        "enum"
      case "swift.protocol":
        "protocol"
      case "swift.actor":
        "actor"
      case "swift.macro":
        "macro"
      case "swift.func",
           "swift.method",
           "swift.type.method":
        "func"
      case "swift.typealias":
        "typealias"
      case "swift.property",
           "swift.type.property",
           "swift.var":
        "var"
      case let kind where kind.contains("extension"):
        "extension"
      default:
        "symbol"
    }
  }

  /// Returns a formatted type label for an extension.
  ///
  /// This method creates a label like "Task extension" for extensions to external types.
  ///
  /// - Parameter extendedType: The name of the type being extended.
  /// - Returns: Formatted extension label (e.g., "Task extension").
  private func getTypeLabelForExtension(extendedType: String) -> String {
    "\(extendedType) extension"
  }

  /// Generates a Table of Contents table for all symbols in the module.
  ///
  /// This method creates a markdown table listing all symbols (including nested types)
  /// in the exact order they appear in the Public Interface section.
  ///
  /// - Parameters:
  ///   - orderedSymbols: Top-level symbols in display order (main + remaining).
  ///   - extensionGroups: Extension groups sorted by extended type name.
  ///   - allSymbolsByPath: Map of all symbols by their path for nested type lookup.
  /// - Returns: Markdown table string with Type and Name columns.
  private func generateQuickReference(orderedSymbols: [SymbolGraph.Symbol],
                                      extensionGroups: [(String, [SymbolGraph.Symbol])],
                                      allSymbolsByPath: [String: SymbolGraph.Symbol]) -> String
  {
    var tableRows: [(type: String, name: String)] = []

    /// Recursively collect a symbol and all its nested types in display order
    func collectSymbolsRecursively(_ symbol: SymbolGraph.Symbol) {
      let typeLabel = getTypeLabel(for: symbol)
      tableRows.append((type: typeLabel, name: symbol.names.title))

      /// Get direct children in the same order as generateInterfaceDeclaration
      let currentPathLength = symbol.pathComponents.count
      let directChildren = allSymbolsByPath.values.filter { child in
        child.pathComponents.count == currentPathLength + 1 &&
          child.pathComponents.prefix(currentPathLength) == symbol.pathComponents[...]
      }

      /// Separate nested types from members (same logic as generateInterfaceDeclaration)
      let nestedTypes = directChildren.filter {
        ["swift.struct", "swift.class", "swift.enum", "swift.protocol"].contains($0.kind.identifier)
      }

      /// Sort nested types by name and recursively collect them
      for nestedType in nestedTypes.sorted(by: { $0.names.title < $1.names.title }) {
        collectSymbolsRecursively(nestedType)
      }
    }

    /// Collect all top-level symbols and their nested types
    for symbol in orderedSymbols {
      collectSymbolsRecursively(symbol)
    }

    /// Add extension groups
    for (extendedType, _) in extensionGroups {
      let extensionLabel = getTypeLabelForExtension(extendedType: extendedType)
      tableRows.append((type: extensionLabel, name: extendedType))
    }

    /// Generate markdown table
    if tableRows.isEmpty {
      return ""
    }

    var markdown = "### Table of Contents\n\n"
    markdown += "| Type | Name |\n"
    markdown += "| --- | --- |\n"

    for row in tableRows {
      markdown += "| \(row.type) | `\(row.name)` |\n"
    }

    markdown += "\n"
    return markdown
  }

  /// Generates a code block for a top-level symbol with its own heading.
  ///
  /// This method creates an H4 heading followed by a code fence containing
  /// the complete interface declaration for the symbol and its members.
  ///
  /// - Parameters:
  ///   - symbol: The top-level symbol to generate a block for.
  ///   - allSymbolsByPath: Map of all symbols by their path for nested type lookup.
  ///   - relationships: Symbol relationships for inheritance/conformance.
  /// - Returns: Markdown block with heading and code fence.
  private func generateTopLevelSymbolBlock(symbol: SymbolGraph.Symbol,
                                           allSymbolsByPath: [String: SymbolGraph.Symbol],
                                           relationships: [SymbolGraph.Relationship]) -> String
  {
    let typeLabel = getTypeLabel(for: symbol)
    var markdown = "#### \(typeLabel) \(symbol.names.title)\n\n"
    markdown += "```swift\n"
    markdown += generateInterfaceDeclaration(
      symbol: symbol,
      allSymbolsByPath: allSymbolsByPath,
      relationships: relationships,
      indent: ""
    )
    markdown += "```\n\n"
    return markdown
  }

  /// Generates a code block for an extension with its own heading.
  ///
  /// This method creates an H4 heading for an extension followed by a code fence
  /// containing the extension's methods and properties.
  ///
  /// - Parameters:
  ///   - extendedType: Name of the type being extended.
  ///   - methods: Methods and properties in the extension.
  /// - Returns: Markdown block with heading and code fence.
  private func generateExtensionBlock(extendedType: String, methods: [SymbolGraph.Symbol]) -> String {
    let typeLabel = getTypeLabelForExtension(extendedType: extendedType)
    var markdown = "#### \(typeLabel)\n\n"
    markdown += "```swift\n"
    markdown += generateExtensionInterface(extendedType: extendedType, methods: methods)
    markdown += "```\n\n"
    return markdown
  }

  /// Generates a code block for global functions and variables.
  ///
  /// This method creates an H4 "Globals" heading followed by a code fence
  /// containing standalone functions, macros, and variables.
  ///
  /// - Parameter globals: Array of global symbols (functions, macros, variables).
  /// - Returns: Markdown block with heading and code fence.
  private func generateGlobalsBlock(globals: [SymbolGraph.Symbol]) -> String {
    if globals.isEmpty {
      return ""
    }

    var markdown = "#### Globals\n\n"
    markdown += "```swift\n"

    for (index, symbol) in globals.enumerated() {
      if index > 0 {
        markdown += "\n"
      }

      /// Add doc comment
      markdown += markdownFormatter.formatDocComment(symbol.docComment, indent: "")

      /// Add declaration
      if let fragments = symbol.declarationFragments {
        let declaration = declarationFormatter.formatDeclaration(fragments: fragments, addPublic: true)
        markdown += "\(declaration)\n"
      }
    }

    markdown += "```\n\n"
    return markdown
  }

  /// Detects if a symbol is re-exported from another module.
  ///
  /// This method filters out symbols that come from external frameworks through
  /// @_exported import statements. It examines the precise identifiers to determine
  /// if a symbol originates from outside the current module.
  ///
  /// - Parameter symbol: The symbol to check for re-export status.
  /// - Returns: true if the symbol is re-exported and should be filtered out by default,
  ///   false if it's a legitimate module symbol.
  private func isReexportedSymbol(_ symbol: SymbolGraph.Symbol) -> Bool {
    /// Check for external module patterns in the precise identifier
    let preciseID = symbol.identifier.precise

    /// Objective-C symbols (c:objc) are typically re-exported from Apple frameworks
    if preciseID.hasPrefix("c:objc") {
      return true
    }

    /// C symbols (c:) - these are typically re-exported from C frameworks
    if preciseID.hasPrefix("c:") {
      return true
    }

    /// Swift bridging symbols for Objective-C types (s:...So...) that come from re-exports
    /// The "So" prefix in Swift mangling indicates Objective-C types imported via bridging headers
    /// or @_exported imports from system frameworks (e.g., NSString, UIView).
    /// These should be filtered out as they're not part of the module's public interface.
    if preciseID.hasPrefix("s:"), preciseID.contains("So") {
      return true
    }

    return false
  }

  /// Processes a single module and generates its documentation.
  ///
  /// - Parameters:
  ///   - moduleName: The name of the module to process.
  ///   - fileName: The filename of the module's symbol graph file.
  /// - Throws: Errors if the symbol graph cannot be read or documentation generation fails.
  private func processModule(moduleName: String, fileName: String) throws {
    print("Processing module: \(moduleName)")

    /// Read main module file
    let fileURL = symbolGraphsDir.appendingPathComponent(fileName)
    let data = try Data(contentsOf: fileURL)
    let graph = try jsonDecoder.decode(SymbolGraph.self, from: data)

    /// Also read extension files (e.g., ModuleName@Swift.symbols.json) - optimized with shared decoder
    var allSymbols = graph.symbols
    var allRelationships = graph.relationships ?? []
    let fm = FileManager.default
    if let files = try? fm.contentsOfDirectory(atPath: symbolGraphsDir.path) {
      let extensionFiles = files.filter { $0.hasPrefix("\(moduleName)@") && $0.hasSuffix(".symbols.json") }

      /// Pre-allocate arrays to avoid multiple reallocations
      allSymbols.reserveCapacity(allSymbols.count + extensionFiles.count * 10)
      allRelationships.reserveCapacity(allRelationships.count + extensionFiles.count * 5)

      /// Process extension files sequentially with shared decoder and better error handling
      for extFile in extensionFiles {
        let extURL = symbolGraphsDir.appendingPathComponent(extFile)
        do {
          let extData = try Data(contentsOf: extURL)
          let extGraph = try jsonDecoder.decode(SymbolGraph.self, from: extData)
          allSymbols.append(contentsOf: extGraph.symbols)
          if let relationships = extGraph.relationships {
            allRelationships.append(contentsOf: relationships)
          }
        }
        catch {
          print("  Warning: Failed to process extension file \(extFile): \(error.localizedDescription)")
        }
      }
    }

    /// Filter to public API symbols (public and open) and exclude synthesized ones
    /// Also filter out re-exported symbols unless explicitly included
    let publicSymbols = allSymbols.filter {
      ($0.accessLevel == "public" || $0.accessLevel == "open") &&
        !$0.identifier.precise.contains("::SYNTHESIZED::") &&
        (includeReexported || !isReexportedSymbol($0))
    }

    /// Group symbols by type and nesting
    var topLevelSymbols: [SymbolGraph.Symbol] = []
    var allSymbolsByPath: [String: SymbolGraph.Symbol] = [:] // path key -> symbol
    var extensionGroups: [String: [SymbolGraph.Symbol]] = [:] // extended type -> methods

    /// Build a map of all symbols by their path for easy lookup
    for symbol in publicSymbols {
      let pathKey = symbol.pathComponents.joined(separator: ".")
      allSymbolsByPath[pathKey] = symbol
    }

    /// Build a set of top-level symbol names for O(1) lookup (fixes O(nÂ³) complexity)
    let topLevelSymbolNames = Set(publicSymbols.filter { $0.pathComponents.count == 1 }.map(\.names.title))

    /// Identify top-level symbols and extensions
    for symbol in publicSymbols {
      if symbol.pathComponents.count == 1 {
        /// Filter out re-exported symbols from top-level symbols as well
        if includeReexported || !isReexportedSymbol(symbol) {
          topLevelSymbols.append(symbol)
        }
      }
      else if symbol.pathComponents.count > 1 {
        let parent = symbol.pathComponents[0]

        /// Check if parent is one of our defined types using O(1) set lookup
        let hasParentType = topLevelSymbolNames.contains(parent)

        if !hasParentType {
          /// This is an extension to an external type - only include direct children
          /// Also filter out re-exported symbols unless explicitly included
          if symbol.pathComponents.count == 2, includeReexported || !isReexportedSymbol(symbol) {
            if extensionGroups[parent] == nil {
              extensionGroups[parent] = []
            }
            extensionGroups[parent]?.append(symbol)
          }
        }
      }
    }

    /// Filter out empty extension groups
    extensionGroups = extensionGroups.filter { !$0.value.isEmpty }

    /// Skip modules with no symbols or extensions
    if topLevelSymbols.isEmpty, extensionGroups.isEmpty {
      print("  Skipping (no public symbols)")
      return
    }

    /// Generate single module file
    try generateModuleFile(
      moduleName: moduleName,
      symbols: topLevelSymbols,
      allSymbolsByPath: allSymbolsByPath,
      extensionGroups: extensionGroups,
      relationships: allRelationships
    )
  }

  /// Extracts inheritance and conformance information for a symbol.
  ///
  /// - Parameters:
  ///   - symbol: The symbol to analyze for inheritance/conformance.
  ///   - relationships: Array of relationships to search through.
  /// - Returns: Array of type names that the symbol inherits from or conforms to,
  ///   sorted deterministically (inheritance first, then conformances, alphabetically within each group).
  private func getInheritanceConformance(for symbol: SymbolGraph.Symbol,
                                         relationships: [SymbolGraph.Relationship]) -> [String]
  {
    let sourceID = symbol.identifier.precise
    var inheritedTypes: [String] = []
    var conformedTypes: [String] = []

    /// Skip compiler-synthesized or inherited conformances that clutter the output
    let skipTypes = Set([
      "CVarArg",
      "Hashable",
      "Equatable",
      "Copyable",
      "CustomStringConvertible",
      "CustomDebugStringConvertible",
    ])

    /// Find all inheritsFrom and conformsTo relationships
    let relevantRelationships = relationships.filter {
      $0.source == sourceID && ($0.kind == "inheritsFrom" || $0.kind == "conformsTo")
    }

    for relationship in relevantRelationships {
      if let typeName = declarationFormatter.extractTypeName(from: relationship.target) {
        if !skipTypes.contains(typeName) {
          if relationship.kind == "inheritsFrom" {
            inheritedTypes.append(typeName)
          }
          else {
            conformedTypes.append(typeName)
          }
        }
      }
    }

    /// Deduplicate and sort each group alphabetically for deterministic output
    let uniqueInherited = Array(Set(inheritedTypes)).sorted()
    let uniqueConformed = Array(Set(conformedTypes)).sorted()

    /// Return inheritance first, then conformances
    return uniqueInherited + uniqueConformed
  }

  /// Generates the module documentation file.
  ///
  /// - Parameters:
  ///   - moduleName: Name of the module
  ///   - symbols: Top-level symbols
  ///   - allSymbolsByPath: All symbols mapped by path
  ///   - extensionGroups: Extension groups
  ///   - relationships: Symbol relationships
  /// - Throws: Errors if file cannot be written
  private func generateModuleFile(moduleName: String, symbols: [SymbolGraph.Symbol],
                                  allSymbolsByPath: [String: SymbolGraph.Symbol],
                                  extensionGroups: [String: [SymbolGraph.Symbol]],
                                  relationships: [SymbolGraph.Relationship]) throws
  {
    /// Pre-allocate markdown components array for efficient string building
    var markdownComponents: [String] = []
    markdownComponents.reserveCapacity(50) // Estimate typical markdown size

    /// Add module header
    markdownComponents.append("## Module `\(moduleName)`\n\n")

    /// Check for module README.md and include it if found
    if let modulePath = targetPaths[moduleName] {
      let readmePath = URL(fileURLWithPath: modulePath).appendingPathComponent("README.md")
      if FileManager.default.fileExists(atPath: readmePath.path) {
        do {
          let readmeContent = try String(contentsOf: readmePath, encoding: .utf8)
          /// Remove the title if it matches the module name (avoid duplication)
          var processedContent = readmeContent
          if let firstLine = readmeContent.split(separator: "\n", maxSplits: 1).first,
             firstLine.trimmingCharacters(in: .whitespaces) == "# \(moduleName)"
          {
            /// Skip the first line and any blank lines after it
            let lines = readmeContent.split(separator: "\n", omittingEmptySubsequences: false)
            if lines.count > 1 {
              processedContent = lines.dropFirst().joined(separator: "\n")
                .trimmingCharacters(in: .whitespacesAndNewlines)
            }
          }

          /// Adjust heading levels so the highest heading becomes H3
          processedContent = markdownFormatter.adjustHeadingLevels(in: processedContent)

          markdownComponents.append(processedContent.trimmingCharacters(in: .whitespacesAndNewlines))
          markdownComponents.append("\n\n")
        }
        catch {
          print("  Warning: Found README.md but couldn't read it: \(error.localizedDescription)")
        }
      }
    }

    /// Build dependency graph for hierarchy-based sorting
    let dependencies = sorter.buildDependencyGraph(symbols: symbols, relationships: relationships)

    /// Find the main symbol (if any) that should appear first
    let mainSymbol = sorter.findMainSymbol(symbols: symbols, relationships: relationships, moduleName: moduleName)

    /// Sort symbols by hierarchy (dependencies first, then by type hierarchy)
    let hierarchySortedSymbols = sorter.sortSymbolsByHierarchy(symbols: symbols, dependencies: dependencies)

    /// Separate main symbol from the rest if found
    var orderedSymbols: [SymbolGraph.Symbol] = []

    if let main = mainSymbol {
      orderedSymbols.append(main)
      orderedSymbols
        .append(contentsOf: hierarchySortedSymbols.filter { $0.identifier.precise != main.identifier.precise })
    }
    else {
      orderedSymbols = hierarchySortedSymbols
    }

    /// Sort extension groups using the same hierarchy logic
    var sortedExtensionGroups: [(String, [SymbolGraph.Symbol])] = []
    sortedExtensionGroups.reserveCapacity(extensionGroups.count)

    for (extendedType, methods) in extensionGroups {
      /// Build dependencies for extension methods
      let extDependencies = sorter.buildDependencyGraph(symbols: methods, relationships: relationships)
      /// Sort methods by hierarchy
      let sortedMethods = sorter.sortSymbolsByHierarchy(symbols: methods, dependencies: extDependencies)
      sortedExtensionGroups.append((extendedType, sortedMethods))
    }

    /// Sort extension groups by extended type name
    sortedExtensionGroups.sort { $0.0 < $1.0 }

    /// Generate Table of Contents table
    let quickRef = generateQuickReference(
      orderedSymbols: orderedSymbols,
      extensionGroups: sortedExtensionGroups,
      allSymbolsByPath: allSymbolsByPath
    )
    if !quickRef.isEmpty {
      markdownComponents.append(quickRef)
    }

    /// Add Public interface heading
    markdownComponents.append("### Public interface\n\n")

    /// Separate symbols into constructs (with bodies) and globals (standalone)
    let constructKinds: Set<String> = ["swift.class", "swift.struct", "swift.enum", "swift.protocol", "swift.actor"]
    let constructs = orderedSymbols.filter { constructKinds.contains($0.kind.identifier) }
    let globals = orderedSymbols.filter { !constructKinds.contains($0.kind.identifier) }

    /// Generate code block for each construct
    for construct in constructs {
      markdownComponents.append(generateTopLevelSymbolBlock(
        symbol: construct,
        allSymbolsByPath: allSymbolsByPath,
        relationships: relationships
      ))
    }

    /// Generate code blocks for extension groups
    for (extendedType, methods) in sortedExtensionGroups {
      if !methods.isEmpty {
        markdownComponents.append(generateExtensionBlock(extendedType: extendedType, methods: methods))
      }
    }

    /// Generate globals block if any exist
    if !globals.isEmpty {
      markdownComponents.append(generateGlobalsBlock(globals: globals))
    }

    /// Add timestamp at the bottom
    let dateFormatter = DateFormatter()
    dateFormatter.dateFormat = "yyyy-MM-dd HH:mm:ss Z"
    let timestamp = dateFormatter.string(from: Date())
    markdownComponents.append("<!-- Generated by interfazzle.swift on \(timestamp) -->\n")

    /// Join all components efficiently
    let markdown = markdownComponents.joined()

    let fileURL = outputDir.appendingPathComponent("\(moduleName).md")
    try markdown.write(to: fileURL, atomically: true, encoding: .utf8)
    print("  Generated \(moduleName).md")
  }

  /// Generates interface declaration for a symbol and its members.
  ///
  /// - Parameters:
  ///   - symbol: The symbol to generate declaration for
  ///   - allSymbolsByPath: All symbols mapped by path
  ///   - relationships: Symbol relationships
  ///   - indent: Current indentation level
  /// - Returns: Generated declaration string
  private func generateInterfaceDeclaration(symbol: SymbolGraph.Symbol,
                                            allSymbolsByPath: [String: SymbolGraph.Symbol],
                                            relationships: [SymbolGraph.Relationship],
                                            indent: String) -> String
  {
    var result = ""

    /// Add doc comment for the type
    result += markdownFormatter.formatDocComment(symbol.docComment, indent: indent)

    /// Type declaration
    if let fragments = symbol.declarationFragments {
      var declaration = declarationFormatter.formatDeclaration(fragments: fragments, addPublic: true)

      /// Add inheritance/conformance for classes, structs, and enums only
      /// Protocols already include inheritance in their declaration fragments
      let needsInheritance = ["swift.class", "swift.struct", "swift.enum"].contains(symbol.kind.identifier)
      if needsInheritance {
        let inherited = getInheritanceConformance(for: symbol, relationships: relationships)
        if !inherited.isEmpty {
          declaration += ": " + inherited.joined(separator: ", ")
        }
      }

      /// For standalone functions/macros, just add the declaration
      if symbol.kind.identifier == "swift.func" || symbol.kind.identifier == "swift.macro" {
        result += "\(indent)\(declaration)\n"
        return result
      }

      result += "\(indent)\(declaration) {\n"
    }

    /// Get direct children only (path length = current path length + 1)
    let currentPathLength = symbol.pathComponents.count
    let directChildren = allSymbolsByPath.values.filter { child in
      child.pathComponents.count == currentPathLength + 1 &&
        child.pathComponents.prefix(currentPathLength) == symbol.pathComponents[...]
    }

    /// Separate nested types from members
    let nestedTypes = directChildren.filter {
      ["swift.struct", "swift.class", "swift.enum", "swift.protocol"].contains($0.kind.identifier)
    }
    let members = directChildren.filter { member in
      !nestedTypes.contains { $0.pathComponents == member.pathComponents }
    }

    /// Group members by kind
    let typeProperties = members.filter { $0.kind.identifier.contains("type.property") }
    let typeMethods = members.filter { $0.kind.identifier.contains("type.method") }
    let properties = members.filter {
      $0.kind.identifier.contains("property") && !$0.kind.identifier.contains("type.property")
    }
    let methods = members.filter {
      ($0.kind.identifier.contains("method") || $0.kind.identifier.contains("init")) &&
        !$0.kind.identifier.contains("type.method")
    }
    let enumCases = members.filter { $0.kind.identifier == "swift.enum.case" }

    let memberIndent = indent + "  "
    var hasContent = false

    /// Render nested types first
    for nestedType in nestedTypes.sorted(by: { $0.names.title < $1.names.title }) {
      if hasContent {
        result += "\n"
      }
      result += generateInterfaceDeclaration(
        symbol: nestedType,
        allSymbolsByPath: allSymbolsByPath,
        relationships: relationships,
        indent: memberIndent
      )
      hasContent = true
    }

    /// Render type properties
    for prop in typeProperties.sorted(by: { $0.names.title < $1.names.title }) {
      if hasContent {
        result += "\n"
      }
      result += markdownFormatter.formatDocComment(prop.docComment, indent: memberIndent)
      if let fragments = prop.declarationFragments {
        let declaration = declarationFormatter.formatDeclaration(fragments: fragments, addPublic: true)
        result += "\(memberIndent)\(declaration)\n"
      }
      hasContent = true
    }

    /// Render instance properties
    for prop in properties.sorted(by: { $0.names.title < $1.names.title }) {
      if hasContent {
        result += "\n"
      }
      result += markdownFormatter.formatDocComment(prop.docComment, indent: memberIndent)
      if let fragments = prop.declarationFragments {
        let declaration = declarationFormatter.formatDeclaration(fragments: fragments, addPublic: true)
        result += "\(memberIndent)\(declaration)\n"
      }
      hasContent = true
    }

    /// Render enum cases
    for enumCase in enumCases.sorted(by: { $0.names.title < $1.names.title }) {
      if hasContent {
        result += "\n"
      }
      result += markdownFormatter.formatDocComment(enumCase.docComment, indent: memberIndent)
      if let fragments = enumCase.declarationFragments {
        let declaration = declarationFormatter.formatDeclaration(fragments: fragments, addPublic: true)
        result += "\(memberIndent)\(declaration)\n"
      }
      hasContent = true
    }

    /// Render type methods
    for method in typeMethods.sorted(by: { $0.names.title < $1.names.title }) {
      if hasContent {
        result += "\n"
      }
      result += markdownFormatter.formatDocComment(method.docComment, indent: memberIndent)
      if let fragments = method.declarationFragments {
        let declaration = declarationFormatter.formatDeclaration(fragments: fragments, addPublic: true)
        result += "\(memberIndent)\(declaration)\n"
      }
      hasContent = true
    }

    /// Render instance methods
    for method in methods.sorted(by: { $0.names.title < $1.names.title }) {
      if hasContent {
        result += "\n"
      }
      result += markdownFormatter.formatDocComment(method.docComment, indent: memberIndent)
      if let fragments = method.declarationFragments {
        let declaration = declarationFormatter.formatDeclaration(fragments: fragments, addPublic: true)
        result += "\(memberIndent)\(declaration)\n"
      }
      hasContent = true
    }

    result += "\(indent)}\n"
    return result
  }

  /// Generates extension interface declaration.
  ///
  /// - Parameters:
  ///   - extendedType: Name of the type being extended
  ///   - methods: Methods in the extension
  /// - Returns: Generated extension declaration string
  private func generateExtensionInterface(extendedType: String, methods: [SymbolGraph.Symbol]) -> String {
    var result = ""

    result += "extension \(extendedType) {\n"

    /// Group by kind
    let properties = methods.filter { $0.kind.identifier.contains("property") }
    let functions = methods.filter { $0.kind.identifier.contains("method") || $0.kind.identifier.contains("func") }

    var allMembers = properties + functions
    allMembers.sort { $0.names.title < $1.names.title }

    for (index, member) in allMembers.enumerated() {
      if index > 0 {
        result += "\n"
      }
      result += markdownFormatter.formatDocComment(member.docComment, indent: "  ")
      if let fragments = member.declarationFragments {
        let declaration = declarationFormatter.formatDeclaration(fragments: fragments, addPublic: true)
        result += "  \(declaration)\n"
      }
    }

    result += "}\n"
    return result
  }
}
