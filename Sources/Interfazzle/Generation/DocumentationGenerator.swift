import Foundation

/// Generates Markdown documentation from Swift symbol graph files.
///
/// This class is responsible for processing Swift symbol graphs and converting them
/// into human-readable Markdown documentation. It handles symbol filtering, hierarchy
/// organization, and proper formatting of the output documentation.
public class DocumentationGenerator {
  // MARK: - Properties

  /// The directory containing symbol graph files to process.
  ///
  /// This directory should contain .symbols.json files generated by the Swift compiler.
  private let symbolGraphsDir: URL

  /// The directory where generated Markdown documentation will be written.
  ///
  /// Each module will generate a separate .md file in this directory.
  private let outputDir: URL

  /// Mapping of target names to their file system paths.
  ///
  /// This is used to locate README.md files within each target's directory
  /// and include them in the generated documentation.
  private let targetPaths: [String: String] // target name -> path

  /// Whether to include re-exported symbols in the documentation.
  ///
  /// When false, symbols from external modules are filtered out to focus
  /// on the package's own API. When true, all symbols are included.
  private let includeReexported: Bool

  /// Helper for sorting symbols.
  private let sorter = SymbolSorter()

  /// Helper for formatting declarations.
  private let declarationFormatter = DeclarationFormatter()

  /// Helper for formatting markdown.
  private let markdownFormatter = MarkdownFormatter()

  // MARK: - Lifecycle

  /// Initializes a new DocumentationGenerator instance.
  ///
  /// - Parameters:
  ///   - symbolGraphsDir: The directory containing symbol graph files.
  ///   - outputDir: The directory where documentation will be written.
  ///   - targetPaths: Mapping of target names to their source directory paths.
  ///   - includeReexported: Whether to include re-exported symbols from external modules.
  public init(symbolGraphsDir: URL, outputDir: URL, targetPaths: [String: String], includeReexported: Bool = false) {
    self.symbolGraphsDir = symbolGraphsDir
    self.outputDir = outputDir
    self.targetPaths = targetPaths
    self.includeReexported = includeReexported
  }

  // MARK: - Functions

  /// Generates documentation for all modules in the symbol graphs directory.
  ///
  /// This is the main entry point for documentation generation. It scans the symbol
  /// graphs directory for module files and processes each one to create Markdown
  /// documentation. Modules can be filtered using the includeOnly parameter.
  ///
  /// - Parameter includeOnly: Optional set of module names to process. If nil, all public
  ///   product modules will be processed. This allows filtering to specific modules.
  /// - Throws: Errors if the symbol graphs directory cannot be read or processing fails.
  public func generate(includeOnly: Set<String>? = nil) throws {
    let fm = FileManager.default

    guard let files = try? fm.contentsOfDirectory(atPath: symbolGraphsDir.path) else {
      print("Error: Cannot read symbol graphs directory")
      return
    }

    /// Process only main module files (not @Module.symbols.json)
    let mainFiles = files.filter { $0.hasSuffix(".symbols.json") && !$0.contains("@") }

    for file in mainFiles {
      let moduleName = file.replacingOccurrences(of: ".symbols.json", with: "")

      /// Filter to included modules if specified
      if let includeOnly, !includeOnly.contains(moduleName) {
        continue
      }

      try processModule(moduleName: moduleName, fileName: file)
    }
  }

  // MARK: - Private Functions

  /// Detects if a symbol is re-exported from another module.
  ///
  /// This method filters out symbols that come from external frameworks through
  /// @_exported import statements. It examines the precise identifiers to determine
  /// if a symbol originates from outside the current module.
  ///
  /// - Parameter symbol: The symbol to check for re-export status.
  /// - Returns: true if the symbol is re-exported and should be filtered out by default,
  ///   false if it's a legitimate module symbol.
  private func isReexportedSymbol(_ symbol: SymbolGraph.Symbol) -> Bool {
    /// Check for external module patterns in the precise identifier
    let preciseID = symbol.identifier.precise

    /// Objective-C symbols (c:objc) are typically re-exported from Apple frameworks
    if preciseID.hasPrefix("c:objc") {
      return true
    }

    /// C symbols (c:) - these are typically re-exported from C frameworks
    if preciseID.hasPrefix("c:") {
      return true
    }

    /// Swift bridging symbols for Objective-C types (s:...So...) that come from re-exports
    if preciseID.hasPrefix("s:"), preciseID.contains("So"), !preciseID.contains("Example") {
      return true
    }

    return false
  }

  /// Processes a single module and generates its documentation.
  ///
  /// - Parameters:
  ///   - moduleName: The name of the module to process.
  ///   - fileName: The filename of the module's symbol graph file.
  /// - Throws: Errors if the symbol graph cannot be read or documentation generation fails.
  private func processModule(moduleName: String, fileName: String) throws {
    print("Processing module: \(moduleName)")

    /// Read main module file
    let fileURL = symbolGraphsDir.appendingPathComponent(fileName)
    let data = try Data(contentsOf: fileURL)
    let graph = try JSONDecoder().decode(SymbolGraph.self, from: data)

    /// Also read extension files (e.g., ModuleName@Swift.symbols.json)
    var allSymbols = graph.symbols
    var allRelationships = graph.relationships ?? []
    let fm = FileManager.default
    if let files = try? fm.contentsOfDirectory(atPath: symbolGraphsDir.path) {
      let extensionFiles = files.filter { $0.hasPrefix("\(moduleName)@") && $0.hasSuffix(".symbols.json") }
      for extFile in extensionFiles {
        let extURL = symbolGraphsDir.appendingPathComponent(extFile)
        if let extData = try? Data(contentsOf: extURL),
           let extGraph = try? JSONDecoder().decode(SymbolGraph.self, from: extData)
        {
          allSymbols.append(contentsOf: extGraph.symbols)
          if let relationships = extGraph.relationships {
            allRelationships.append(contentsOf: relationships)
          }
        }
      }
    }

    /// Filter to public API symbols (public and open) and exclude synthesized ones
    /// Also filter out re-exported symbols unless explicitly included
    let publicSymbols = allSymbols.filter {
      ($0.accessLevel == "public" || $0.accessLevel == "open") &&
        !$0.identifier.precise.contains("::SYNTHESIZED::") &&
        (includeReexported || !isReexportedSymbol($0))
    }

    /// Group symbols by type and nesting
    var topLevelSymbols: [SymbolGraph.Symbol] = []
    var allSymbolsByPath: [String: SymbolGraph.Symbol] = [:] // path key -> symbol
    var extensionGroups: [String: [SymbolGraph.Symbol]] = [:] // extended type -> methods

    /// Build a map of all symbols by their path for easy lookup
    for symbol in publicSymbols {
      let pathKey = symbol.pathComponents.joined(separator: ".")
      allSymbolsByPath[pathKey] = symbol
    }

    /// Identify top-level symbols and extensions
    for symbol in publicSymbols {
      if symbol.pathComponents.count == 1 {
        /// Filter out re-exported symbols from top-level symbols as well
        if includeReexported || !isReexportedSymbol(symbol) {
          topLevelSymbols.append(symbol)
        }
      }
      else if symbol.pathComponents.count > 1 {
        let parent = symbol.pathComponents[0]

        /// Check if parent is one of our defined types
        let hasParentType = publicSymbols.contains { $0.pathComponents.count == 1 && $0.names.title == parent }

        if !hasParentType {
          /// This is an extension to an external type - only include direct children
          /// Also filter out re-exported symbols unless explicitly included
          if symbol.pathComponents.count == 2, includeReexported || !isReexportedSymbol(symbol) {
            if extensionGroups[parent] == nil {
              extensionGroups[parent] = []
            }
            extensionGroups[parent]?.append(symbol)
          }
        }
      }
    }

    /// Filter out empty extension groups
    extensionGroups = extensionGroups.filter { !$0.value.isEmpty }

    /// Skip modules with no symbols or extensions
    if topLevelSymbols.isEmpty, extensionGroups.isEmpty {
      print("  Skipping (no public symbols)")
      return
    }

    /// Generate single module file
    try generateModuleFile(
      moduleName: moduleName,
      symbols: topLevelSymbols,
      allSymbolsByPath: allSymbolsByPath,
      extensionGroups: extensionGroups,
      relationships: allRelationships
    )
  }

  /// Extracts inheritance and conformance information for a symbol.
  ///
  /// - Parameters:
  ///   - symbol: The symbol to analyze for inheritance/conformance.
  ///   - relationships: Array of relationships to search through.
  /// - Returns: Array of type names that the symbol inherits from or conforms to.
  private func getInheritanceConformance(for symbol: SymbolGraph.Symbol,
                                         relationships: [SymbolGraph.Relationship]) -> [String]
  {
    let sourceID = symbol.identifier.precise
    var types: [String] = []

    /// Find all inheritsFrom and conformsTo relationships
    let relevantRelationships = relationships.filter {
      $0.source == sourceID && ($0.kind == "inheritsFrom" || $0.kind == "conformsTo")
    }

    for relationship in relevantRelationships {
      if let typeName = declarationFormatter.extractTypeName(from: relationship.target) {
        /// Skip compiler-synthesized or inherited conformances that clutter the output
        let skipTypes = [
          "CVarArg",
          "Hashable",
          "Equatable",
          "Copyable",
          "CustomStringConvertible",
          "CustomDebugStringConvertible",
        ]
        if !skipTypes.contains(typeName) {
          types.append(typeName)
        }
      }
    }

    /// Deduplicate while preserving order (inheritance first, then conformances)
    var seen = Set<String>()
    return types.filter { seen.insert($0).inserted }
  }

  /// Generates the module documentation file.
  ///
  /// - Parameters:
  ///   - moduleName: Name of the module
  ///   - symbols: Top-level symbols
  ///   - allSymbolsByPath: All symbols mapped by path
  ///   - extensionGroups: Extension groups
  ///   - relationships: Symbol relationships
  /// - Throws: Errors if file cannot be written
  private func generateModuleFile(moduleName: String, symbols: [SymbolGraph.Symbol],
                                  allSymbolsByPath: [String: SymbolGraph.Symbol],
                                  extensionGroups: [String: [SymbolGraph.Symbol]],
                                  relationships: [SymbolGraph.Relationship]) throws
  {
    var markdown = "## Module `\(moduleName)`\n\n"

    /// Check for module README.md and include it if found
    if let modulePath = targetPaths[moduleName] {
      let readmePath = URL(fileURLWithPath: modulePath).appendingPathComponent("README.md")
      if FileManager.default.fileExists(atPath: readmePath.path) {
        do {
          let readmeContent = try String(contentsOf: readmePath, encoding: .utf8)
          /// Remove the title if it matches the module name (avoid duplication)
          var processedContent = readmeContent
          if let firstLine = readmeContent.split(separator: "\n", maxSplits: 1).first,
             firstLine.trimmingCharacters(in: .whitespaces) == "# \(moduleName)"
          {
            /// Skip the first line and any blank lines after it
            let lines = readmeContent.split(separator: "\n", omittingEmptySubsequences: false)
            if lines.count > 1 {
              processedContent = lines.dropFirst().joined(separator: "\n")
                .trimmingCharacters(in: .whitespacesAndNewlines)
            }
          }

          /// Adjust heading levels so the highest heading becomes H3
          processedContent = markdownFormatter.adjustHeadingLevels(in: processedContent)

          markdown += processedContent.trimmingCharacters(in: .whitespacesAndNewlines) + "\n\n"
        }
        catch {
          print("  Warning: Found README.md but couldn't read it: \(error.localizedDescription)")
        }
      }
    }

    /// Build dependency graph for hierarchy-based sorting
    let dependencies = sorter.buildDependencyGraph(symbols: symbols, relationships: relationships)

    /// Find the main symbol (if any) that should appear first
    let mainSymbol = sorter.findMainSymbol(symbols: symbols, relationships: relationships, moduleName: moduleName)

    /// Sort symbols by hierarchy (dependencies first, then by type hierarchy)
    let hierarchySortedSymbols = sorter.sortSymbolsByHierarchy(symbols: symbols, dependencies: dependencies)

    /// Separate main symbol from the rest if found
    var orderedSymbols: [SymbolGraph.Symbol] = []
    var remainingSymbols: [SymbolGraph.Symbol] = []

    if let main = mainSymbol {
      orderedSymbols.append(main)
      remainingSymbols = hierarchySortedSymbols.filter { $0.identifier.precise != main.identifier.precise }
    }
    else {
      remainingSymbols = hierarchySortedSymbols
    }

    /// Add public interface heading before first code block
    var hasAddedHeading = false
    func writeInterfaceBlock(_ symbols: [SymbolGraph.Symbol]) {
      if symbols.isEmpty {
        return
      }

      if !hasAddedHeading {
        markdown += "### Public interface\n\n"
        hasAddedHeading = true
      }

      markdown += "```swift\n"
      for (index, symbol) in symbols.enumerated() {
        if index > 0 {
          markdown += "\n"
        }
        markdown += generateInterfaceDeclaration(
          symbol: symbol,
          allSymbolsByPath: allSymbolsByPath,
          relationships: relationships,
          indent: ""
        )
      }
      markdown += "```\n\n"
    }

    /// Write main symbol first if found
    if !orderedSymbols.isEmpty {
      writeInterfaceBlock(orderedSymbols)
    }

    /// Write remaining symbols
    writeInterfaceBlock(remainingSymbols)

    /// Write extension groups (extensions to external types) with hierarchy-based ordering
    if !extensionGroups.isEmpty {
      if !hasAddedHeading {
        markdown += "### Public interface\n\n"
        hasAddedHeading = true
      }

      markdown += "```swift\n"

      /// Sort extension groups using the same hierarchy logic
      var sortedExtensionGroups: [(String, [SymbolGraph.Symbol])] = []

      for (extendedType, methods) in extensionGroups {
        /// Build dependencies for extension methods
        let extDependencies = sorter.buildDependencyGraph(symbols: methods, relationships: relationships)
        /// Sort methods by hierarchy
        let sortedMethods = sorter.sortSymbolsByHierarchy(symbols: methods, dependencies: extDependencies)
        sortedExtensionGroups.append((extendedType, sortedMethods))
      }

      /// Sort extension groups by extended type name
      sortedExtensionGroups.sort { $0.0 < $1.0 }

      for (index, (extendedType, methods)) in sortedExtensionGroups.enumerated() {
        /// Only generate extension if it has members after filtering
        if !methods.isEmpty {
          if index > 0 {
            markdown += "\n"
          }
          markdown += generateExtensionInterface(extendedType: extendedType, methods: methods)
        }
      }
      markdown += "```\n\n"
    }

    /// Add timestamp at the bottom
    let dateFormatter = DateFormatter()
    dateFormatter.dateFormat = "yyyy-MM-dd HH:mm:ss Z"
    let timestamp = dateFormatter.string(from: Date())
    markdown += "<!-- Generated by interfazzle.swift on \(timestamp) -->\n"

    let fileURL = outputDir.appendingPathComponent("\(moduleName).md")
    try markdown.write(to: fileURL, atomically: true, encoding: .utf8)
    print("  Generated \(moduleName).md")
  }

  /// Generates interface declaration for a symbol and its members.
  ///
  /// - Parameters:
  ///   - symbol: The symbol to generate declaration for
  ///   - allSymbolsByPath: All symbols mapped by path
  ///   - relationships: Symbol relationships
  ///   - indent: Current indentation level
  /// - Returns: Generated declaration string
  private func generateInterfaceDeclaration(symbol: SymbolGraph.Symbol,
                                            allSymbolsByPath: [String: SymbolGraph.Symbol],
                                            relationships: [SymbolGraph.Relationship],
                                            indent: String) -> String
  {
    var result = ""

    /// Add doc comment for the type
    result += markdownFormatter.formatDocComment(symbol.docComment, indent: indent)

    /// Type declaration
    if let fragments = symbol.declarationFragments {
      var declaration = declarationFormatter.formatDeclaration(fragments: fragments, addPublic: true)

      /// Add inheritance/conformance for classes, structs, and enums only
      /// Protocols already include inheritance in their declaration fragments
      let needsInheritance = ["swift.class", "swift.struct", "swift.enum"].contains(symbol.kind.identifier)
      if needsInheritance {
        let inherited = getInheritanceConformance(for: symbol, relationships: relationships)
        if !inherited.isEmpty {
          declaration += ": " + inherited.joined(separator: ", ")
        }
      }

      /// For standalone functions/macros, just add the declaration
      if symbol.kind.identifier == "swift.func" || symbol.kind.identifier == "swift.macro" {
        result += "\(indent)\(declaration)\n"
        return result
      }

      result += "\(indent)\(declaration) {\n"
    }

    /// Get direct children only (path length = current path length + 1)
    let currentPathLength = symbol.pathComponents.count
    let directChildren = allSymbolsByPath.values.filter { child in
      child.pathComponents.count == currentPathLength + 1 &&
        child.pathComponents.prefix(currentPathLength) == symbol.pathComponents[...]
    }

    /// Separate nested types from members
    let nestedTypes = directChildren.filter {
      ["swift.struct", "swift.class", "swift.enum", "swift.protocol"].contains($0.kind.identifier)
    }
    let members = directChildren.filter { member in
      !nestedTypes.contains { $0.pathComponents == member.pathComponents }
    }

    /// Group members by kind
    let typeProperties = members.filter { $0.kind.identifier.contains("type.property") }
    let typeMethods = members.filter { $0.kind.identifier.contains("type.method") }
    let properties = members.filter {
      $0.kind.identifier.contains("property") && !$0.kind.identifier.contains("type.property")
    }
    let methods = members.filter {
      ($0.kind.identifier.contains("method") || $0.kind.identifier.contains("init")) &&
        !$0.kind.identifier.contains("type.method")
    }
    let enumCases = members.filter { $0.kind.identifier == "swift.enum.case" }

    let memberIndent = indent + "  "
    var hasContent = false

    /// Render nested types first
    for nestedType in nestedTypes.sorted(by: { $0.names.title < $1.names.title }) {
      if hasContent {
        result += "\n"
      }
      result += generateInterfaceDeclaration(
        symbol: nestedType,
        allSymbolsByPath: allSymbolsByPath,
        relationships: relationships,
        indent: memberIndent
      )
      hasContent = true
    }

    /// Render type properties
    for prop in typeProperties.sorted(by: { $0.names.title < $1.names.title }) {
      if hasContent {
        result += "\n"
      }
      result += markdownFormatter.formatDocComment(prop.docComment, indent: memberIndent)
      if let fragments = prop.declarationFragments {
        let declaration = declarationFormatter.formatDeclaration(fragments: fragments, addPublic: true)
        result += "\(memberIndent)\(declaration)\n"
      }
      hasContent = true
    }

    /// Render instance properties
    for prop in properties.sorted(by: { $0.names.title < $1.names.title }) {
      if hasContent {
        result += "\n"
      }
      result += markdownFormatter.formatDocComment(prop.docComment, indent: memberIndent)
      if let fragments = prop.declarationFragments {
        let declaration = declarationFormatter.formatDeclaration(fragments: fragments, addPublic: true)
        result += "\(memberIndent)\(declaration)\n"
      }
      hasContent = true
    }

    /// Render enum cases
    for enumCase in enumCases.sorted(by: { $0.names.title < $1.names.title }) {
      if hasContent {
        result += "\n"
      }
      result += markdownFormatter.formatDocComment(enumCase.docComment, indent: memberIndent)
      if let fragments = enumCase.declarationFragments {
        let declaration = declarationFormatter.formatDeclaration(fragments: fragments, addPublic: true)
        result += "\(memberIndent)\(declaration)\n"
      }
      hasContent = true
    }

    /// Render type methods
    for method in typeMethods.sorted(by: { $0.names.title < $1.names.title }) {
      if hasContent {
        result += "\n"
      }
      result += markdownFormatter.formatDocComment(method.docComment, indent: memberIndent)
      if let fragments = method.declarationFragments {
        let declaration = declarationFormatter.formatDeclaration(fragments: fragments, addPublic: true)
        result += "\(memberIndent)\(declaration)\n"
      }
      hasContent = true
    }

    /// Render instance methods
    for method in methods.sorted(by: { $0.names.title < $1.names.title }) {
      if hasContent {
        result += "\n"
      }
      result += markdownFormatter.formatDocComment(method.docComment, indent: memberIndent)
      if let fragments = method.declarationFragments {
        let declaration = declarationFormatter.formatDeclaration(fragments: fragments, addPublic: true)
        result += "\(memberIndent)\(declaration)\n"
      }
      hasContent = true
    }

    result += "\(indent)}\n"
    return result
  }

  /// Generates extension interface declaration.
  ///
  /// - Parameters:
  ///   - extendedType: Name of the type being extended
  ///   - methods: Methods in the extension
  /// - Returns: Generated extension declaration string
  private func generateExtensionInterface(extendedType: String, methods: [SymbolGraph.Symbol]) -> String {
    var result = ""

    result += "extension \(extendedType) {\n"

    /// Group by kind
    let properties = methods.filter { $0.kind.identifier.contains("property") }
    let functions = methods.filter { $0.kind.identifier.contains("method") || $0.kind.identifier.contains("func") }

    var allMembers = properties + functions
    allMembers.sort { $0.names.title < $1.names.title }

    for (index, member) in allMembers.enumerated() {
      if index > 0 {
        result += "\n"
      }
      result += markdownFormatter.formatDocComment(member.docComment, indent: "  ")
      if let fragments = member.declarationFragments {
        let declaration = declarationFormatter.formatDeclaration(fragments: fragments, addPublic: true)
        result += "  \(declaration)\n"
      }
    }

    result += "}\n"
    return result
  }
}
