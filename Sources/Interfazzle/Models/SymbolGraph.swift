import Foundation

/// Represents a Swift symbol graph file structure.
///
/// Symbol graphs are JSON files generated by the Swift compiler that contain
/// information about the symbols (types, functions, properties, etc.) in a module,
/// their relationships, and documentation comments.
public struct SymbolGraph: Codable {
  // MARK: - Nested Types

  /// Represents the module information in a symbol graph.
  ///
  /// This contains basic metadata about the Swift module that the symbol graph describes.
  public struct Module: Codable {
    /// The name of the module.
    ///
    /// This corresponds to the module name that can be imported in Swift code
    /// and typically matches the target name in Package.swift.
    public let name: String
  }

  /// Represents a Swift symbol (type, function, property, etc.) in the symbol graph.
  ///
  /// This is the core data structure that contains all information about a particular
  /// Swift symbol, including its declaration, documentation, and metadata.
  public struct Symbol: Codable {
    // MARK: - Nested Types

    /// Represents the kind of symbol (class, struct, function, etc.).
    ///
    /// The identifier follows a specific naming convention used by the Swift compiler
    /// to categorize different types of symbols.
    public struct Kind: Codable {
      /// The machine-readable identifier for the symbol kind.
      ///
      /// Examples include "swift.class", "swift.struct", "swift.func", "swift.enum", etc.
      public let identifier: String

      /// The human-readable display name for the symbol kind.
      ///
      /// This is a more user-friendly representation of the symbol type.
      public let displayName: String
    }

    /// Represents a unique identifier for a symbol.
    ///
    /// This provides a way to uniquely reference symbols across different
    /// symbol graphs and within relationships.
    public struct Identifier: Codable {
      /// The precise identifier that uniquely identifies this symbol.
      ///
      /// This is a mangled name that includes the full module path and symbol name,
      /// used for precise symbol identification and relationship tracking.
      public let precise: String

      /// The interface language for this symbol.
      ///
      /// For Swift symbols, this is typically "swift". This allows symbol graphs
      /// to potentially contain symbols from different languages.
      public let interfaceLanguage: String
    }

    /// Represents the various names associated with a symbol.
    ///
    /// This includes the primary title and any subheading information
    /// that might be used for display purposes.
    public struct Names: Codable {
      /// The primary title/name of the symbol.
      ///
      /// This is the main name used to identify the symbol in documentation.
      public let title: String

      /// Optional subheading fragments for the symbol.
      ///
      /// This can contain additional type information or other context
      /// that appears after the main symbol name.
      public let subHeading: [DeclarationFragment]?
    }

    /// Represents documentation comments associated with a symbol.
    ///
    /// This contains the structured documentation comments from the source code,
    /// broken down into individual lines for processing.
    public struct DocComment: Codable {
      // MARK: - Nested Types

      /// Represents a single line of documentation comment.
      ///
      /// Each line is stored separately to preserve formatting and allow
      /// for structured processing of documentation content.
      public struct Line: Codable {
        /// The text content of this documentation line.
        ///
        /// This contains the actual comment text from the source code.
        public let text: String
      }

      // MARK: - Properties

      /// Array of lines that make up the complete documentation comment.
      ///
      /// This preserves the original line-by-line structure of the documentation.
      public let lines: [Line]
    }

    /// Represents a fragment of a symbol's declaration.
    ///
    /// Declarations are broken down into fragments to allow for structured
    /// processing and formatting of symbol signatures.
    public struct DeclarationFragment: Codable {
      /// The kind of declaration fragment.
      ///
      /// This indicates what type of token this fragment represents,
      /// such as "keyword", "identifier", "text", "type", etc.
      public let kind: String

      /// The actual text/spelling of this declaration fragment.
      ///
      /// This contains the literal text that appears in the source code.
      public let spelling: String
    }

    /// Represents the signature of a function symbol.
    ///
    /// This contains detailed information about function parameters and return types,
    /// broken down into structured declaration fragments.
    public struct FunctionSignature: Codable {
      // MARK: - Nested Types

      /// Represents a parameter in a function signature.
      ///
      /// This contains the parameter name and its type information
      /// as declaration fragments for structured processing.
      public struct Parameter: Codable {
        /// The name of the parameter.
        ///
        /// This is the identifier used for the parameter in the function signature.
        public let name: String

        /// Declaration fragments describing the parameter's type.
        ///
        /// This contains the type information and any modifiers for the parameter,
        /// broken down into structured fragments.
        public let declarationFragments: [DeclarationFragment]?
      }

      // MARK: - Properties

      /// Array of parameters for this function.
      ///
      /// This may be nil for functions that take no parameters.
      public let parameters: [Parameter]?

      /// Declaration fragments describing the return type.
      ///
      /// This contains the return type information broken down into fragments.
      /// May be nil for functions without explicit return types (Void).
      public let returns: [DeclarationFragment]?
    }

    // MARK: - Properties

    /// The kind of symbol (class, struct, function, etc.).
    ///
    /// This determines how the symbol should be categorized and displayed.
    public let kind: Kind

    /// The unique identifier for this symbol.
    ///
    /// This is used to reference this symbol in relationships and for
    /// cross-symbol graph references.
    public let identifier: Identifier

    /// The path components that form the symbol's full path.
    ///
    /// This represents the hierarchical path to the symbol, such as
    /// ["MyClass", "myMethod"] for a method inside a class.
    public let pathComponents: [String]

    /// The names and display information for this symbol.
    ///
    /// This includes the title and any subheading information.
    public let names: Names

    /// Documentation comments associated with this symbol.
    ///
    /// This contains the structured documentation from the source code.
    /// May be nil if the symbol has no documentation.
    public let docComment: DocComment?

    /// Declaration fragments that make up the symbol's signature.
    ///
    /// This provides the complete declaration broken down into structured tokens.
    /// May be nil for some types of symbols.
    public let declarationFragments: [DeclarationFragment]?

    /// Function signature information for function symbols.
    ///
    /// This contains detailed parameter and return type information.
    /// Only applicable to function/method symbols.
    public let functionSignature: FunctionSignature?

    /// The access level of this symbol.
    ///
    /// This indicates the visibility level (public, internal, private, etc.).
    /// String value such as "public", "internal", "private", "fileprivate", "open".
    public let accessLevel: String
  }

  /// Represents a relationship between two symbols.
  ///
  /// This captures various types of relationships such as inheritance,
  /// conformance, membership, and other connections between symbols.
  public struct Relationship: Codable {
    /// The kind of relationship.
    ///
    /// Examples include "inheritsFrom", "conformsTo", "memberOf", "overrideOf", etc.
    public let kind: String

    /// The precise identifier of the source symbol in this relationship.
    ///
    /// This refers to the symbol that is the source of the relationship.
    public let source: String

    /// The precise identifier of the target symbol in this relationship.
    ///
    /// This refers to the symbol that is the target of the relationship.
    public let target: String
  }

  // MARK: - Properties

  /// Information about the module this symbol graph describes.
  ///
  /// This contains the basic module metadata.
  public let module: Module

  /// Array of all symbols defined in this module.
  ///
  /// This includes all types, functions, properties, and other symbols
  /// that are part of the module's public API.
  public let symbols: [Symbol]

  /// Array of relationships between symbols in this module.
  ///
  /// This captures inheritance hierarchies, protocol conformances,
  /// type memberships, and other symbol relationships.
  /// May be nil if no relationships are defined.
  public let relationships: [Relationship]?
}
